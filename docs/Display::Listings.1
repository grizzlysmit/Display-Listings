.pc
.TH Listings.rakumod 1 2023-12-27
.SH Display::Listings
.SS Table of Contents
.IP \(bu 2m
NAME [#name]
.IP \(bu 2m
AUTHOR [#author]
.IP \(bu 2m
VERSION [#version]
.IP \(bu 2m
TITLE [#title]
.IP \(bu 2m
SUBTITLE [#subtitle]
.IP \(bu 2m
COPYRIGHT [#copyright]
.IP \(bu 2m
Introduction [#introduction]
.IP \(bu 2m
list\-by(…) [#list-by]
.RS 2n
.IP \(bu 2m
Examples: [#examples]
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
A more complete example: [#a-more-complete-example]
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
Another example: [#another-example]
.RE
.RE
.RS 2n
.RS 2n
.IP \(bu 2m
An Example of the above code \fBlist\-editors\-backups(…)\fR at work: [#An-Example-of-the-above-code-list-editors-backups-at-work]
.RE
.RE
.SH "NAME"
Display::Listings 
.SH "AUTHOR"
Francis Grizzly Smit (grizzly@smit\&.id\&.au)
.SH "VERSION"
0\&.1\&.5
.SH "TITLE"
Display::Listings
.SH "SUBTITLE"
A Raku module for displaying lines in a listing\&.
.SH "COPYRIGHT"
LGPL V3\&.0+ LICENSE [https://github.com/grizzlysmit/Display-Listings/blob/main/LICENSE]

Top of Document [#table-of-contents]
.SH Introduction

A \fBRaku\fR module for managing the users GUI Editor preferences in a variety of programs\&. 
.SS list\-by(…)

This is a multi sub it has two signatures\&.

.RS 4m
.EX
multi sub list\-by(Str:D $prefix, Bool:D $colour is copy, Bool:D $syntax, Int:D $page\-length,
                  Regex:D $pattern, Str:D $key\-name, Str:D @fields, %defaults, %rows,
                  Int:D :$start\-cnt = \-3, Bool:D :$starts\-with\-blank = True,
                  Str:D :$overline\-header = '', Bool:D :$underline\-header = True, Str:D :$underline = '=',
                  Bool:D :$put\-line\-at\-bottom = True, Str:D :$line\-at\-bottom = '=', Bool:D :$sort = True,
                  Str:D :%flags = default\-zip\-flags($key\-name, @fields), 
                  Str:D :%between\-flags = default\-zip\-flags($key\-name, @fields), 
                  Str:D :%head\-flags = default\-zip\-flags($key\-name, @fields), 
                  Str:D :%between\-head\-flags = default\-zip\-flags($key\-name, @fields), 
                  :&include\-row:(Str:D $pref, Regex $pat, Str:D $k, Str:D @f, %r \-\-> Bool:D) = &default\-include\-row, 
                  :&head\-value:(Int:D $idx, Str:D $fld, Bool:D $c, Bool:D $syn, Str:D @flds \-\-> Str:D) = &default\-head\-value, 
                  :&head\-between:(Int:D $idx, Str:D $fld, Bool:D $c, Bool:D $syn, Str:D @flds \-\-> Str:D) = &default\-head\-between,
                  :&field\-value:(Int:D $idx, Str:D $fld, $val, Bool:D $c, Bool:D $syn, Str:D @flds, %r \-\-> Str:D) = &default\-field\-value, 
                  :&between:(Int:D $idx, Str:D $fld, Bool:D $c, Bool:D $syn, Str:D @flds, %r \-\-> Str:D) = &default\-between,
                  :&row\-formatting:(Int:D $cnt, Bool:D $c, Bool:D $syn \-\-> Str:D) = &default\-row\-formatting \-\-> Bool:D) is export {


.EE
.RE
.P
Top of Document [#table-of-contents]

And

.RS 4m
.EX
multi sub list\-by(Str:D $prefix, Bool:D $colour is copy, Bool:D $syntax, Int:D $page\-length,
                  Regex:D $pattern, Str:D @fields, %defaults, @rows, Int:D :$start\-cnt = \-3,
                  Bool:D :$starts\-with\-blank = True,
                  Str:D :$overline\-header = '', Bool:D :$underline\-header = True, Str:D :$underline = '=',
                  Bool:D :$put\-line\-at\-bottom = True, Str:D :$line\-at\-bottom = '=', Bool:D :$sort = True,
                  Str:D :%flags = default\-zip\-flags(@fields), 
                  Str:D :%between\-flags = default\-zip\-flags(@fields), 
                  Str:D :%head\-flags = default\-zip\-flags(@fields), 
                  Str:D :%between\-head\-flags = default\-zip\-flags(@fields), 
                  :&include\-row:(Str:D $pref, Regex:D $pat, Int:D $i, Str:D @f, %r \-\-> Bool:D) = &default\-include\-row\-array, 
                  :&head\-value:(Int:D $idx, Str:D $fld, Bool:D $c, Bool:D $syn, Str:D @flds \-\-> Str:D) = &default\-head\-value\-array, 
                  :&head\-between:(Int:D $idx, Str:D $fld, Bool:D $c, Bool:D $syn, Str:D @flds \-\-> Str:D) = &default\-head\-between\-array,
                  :&field\-value:(Int:D $idx, Str:D $fld, $val, Bool:D $c, Bool:D $syn, Str:D @flds, %r \-\-> Str:D) = &default\-field\-value\-array, 
                  :&between:(Int:D $idx, Str:D $fld, Bool:D $c, Bool:D $syn, Str:D @flds, %r \-\-> Str:D) = &default\-between\-array,
                  :&row\-formatting:(Int:D $cnt, Bool:D $c, Bool:D $syn \-\-> Str:D) = &default\-row\-formatting\-array \-\-> Bool:D) is export {


.EE
.RE
.P
\fBNote: you have to be careful writing your own callbacks like :&include\-row you need to get the signature of said callback exactly right or you will run into difficult to debug errors, with no version of the list\-by multi sub matching etc\&.\fR 

Top of Document [#table-of-contents]
.SS Examples:

.RS 4m
.EX
use Display::Listings;

my Str:D $prefix = '';
my Str:D $key\-name = 'key';
my Str:D @fields = 'host', 'port', 'comment';
my   %defaults = port => 22;

my   %rows = one => { host => 'example\&.com', type => 'host', port => 22 },
             two => { type => 'alias', host => 'one', comment => 'An alias' },
             three => { port => 345, host => 'www\&.smit\&.id\&.au', type => 'host',
                                                    comment => 'mine all mine' };
my Bool:D $colour = False;
my Bool:D $syntax = True;
my Int:D $page\-length = 20;
my Regex:D $pattern = rx:i/ ^ \&.* 'smit' \&.* $/;

my @rows = {key => 'one', host => 'example\&.com', type => 'host', port => 22 },
           { type => 'alias', host => 'one', comment => 'An alias', key => 'two', },
           { port => 345, host => 'www\&.smit\&.id\&.au', type => 'host',
                                            comment => 'mine all mine', key => 'three' };

list\-by($prefix, $colour, $syntax, $page\-length, $pattern, $key\-name,
                                                         @fields, %defaults, %rows);

list\-by($prefix, $colour, $syntax, $page\-length, $pattern, @fields, %defaults, @rows);

$pattern = rx/ ^ \&.* $/;

list\-by($prefix, $colour, $syntax, $page\-length, $pattern, $key\-name,
                                                         @fields, %defaults, %rows);

list\-by($prefix, $colour, $syntax, $page\-length, $pattern,
                                                         @fields, %defaults, @rows);


.EE
.RE
.P
Top of Document [#table-of-contents]
.SS A more complete example:

.RS 4m
.EX
use Terminal::ANSI::OO :t;
use Display::Listings;

sub list\-by\-all(Str:D $prefix, Bool:D $colour, Bool:D $syntax,
                    Int:D $page\-length, Regex:D $pattern \-\-> Bool:D) is export {
    my Str:D $key\-name = 'key';
    my Str:D @fields = 'host', 'port', 'comment';
    my   %defaults = port => 22;
    sub include\-row(Str:D $prefix, Regex:D $pattern, Str:D $key,
                                                Str:D @fields, %row \-\-> Bool:D) {
        return True if $key\&.starts\-with($prefix, :ignorecase) && $key ~~ $pattern;
        for @fields \-> $field {
            my Str:D $value = '';
            with %row{$field} { #`««« if %row{$field} does not exist then a Any
                                      will be returned, and if some cases, you
                                      may return undefined values so use some
                                      sort of guard this is one way to do that,
                                      you could use %row{$field}:exists or
                                      :!exists or // perhaps\&.
                                      TIMTOWTDI rules as always\&. »»»
                $value = ~%row{$field};
            }
            return True if $value\&.starts\-with($prefix, :ignorecase)
                                                         && $value ~~ $pattern;
        }
        return False;
    } # sub include\-row(Str:D $prefix, Regex:D $pattern,
                                        Str:D $key, @fields, %row \-\-> Bool:D) #
    sub head\-value(Int:D $indx, Str:D $field, Bool:D $colour,
                                        Bool:D $syntax, Str:D @fields \-\-> Str:D) {
        if $syntax {
            t\&.color(0, 255, 255) ~ $field;
        } elsif $colour {
            t\&.color(0, 255, 255) ~ $field;
        } else {
            return $field;
        }
    } #`««« sub head\-value(Int:D $indx, Str:D $field,
                                        Bool:D $colour, Bool:D $syntax,
                                        Str:D @fields \-\-> Str:D) »»»
    sub head\-between(Int:D $idx, Str:D $field, Bool:D $colour,
                                        Bool:D $syntax, Str:D @fields \-\-> Str:D) {
        if $colour {
            if $syntax {
                given $field {
                    when 'key'     { return t\&.color(0, 255, 255) ~ ' sep '; }
                    when 'host'    { return t\&.color(0, 255, 255) ~ ' : ';   }
                    when 'port'    { return t\&.color(0, 255, 255)   ~ ' # ';   }
                    when 'comment' { return t\&.color(0, 0, 255)   ~ '  ';    }
                    default { return ''; }
                }
            } else {
                given $field {
                    when 'key'     { return t\&.color(0, 255, 255)   ~ ' sep '; }
                    when 'host'    { return t\&.color(0, 255, 255)   ~ ' : ';   }
                    when 'port'    { return t\&.color(0, 255, 255)   ~ ' # ';   }
                    when 'comment' { return t\&.color(0, 255, 255)   ~ '  ';    }
                    default { return ''; }
                }
            }
        } else {
            given $field {
                when 'key'     { return ' sep '; }
                when 'host'    { return ' : ';   }
                when 'port'    { return ' # ';   }
                when 'comment' { return '  ';    }
                default        { return '';      }
            }
        }
    } #`««« sub head\-between(Int:D $idx, Str:D $field, Bool:D $colour,
                            Bool:D $syntax, Str:D @fields \-\-> Str:D) »»»
    sub field\-value(Int:D $idx, Str:D $field, $value, Bool:D $colour,
                        Bool:D $syntax, Str:D @fields, %row \-\-> Str:D) {
        if $syntax {
            given $field {
                when 'key'     { return t\&.color(0, 255, 255) ~ ~$value; }
                when 'host'    {
                    my Str:D $type = %row«type»;
                    if $type eq 'host' {
                        return t\&.color(255, 0, 255) ~ ~$value;
                    } else {
                        return t\&.color(0, 255, 255) ~ ~$value;
                    }
                }
                when 'port'    { 
                    my Str:D $type = %row«type»;
                    if $type eq 'host' {
                        return t\&.color(255, 0, 255) ~ ~$value;
                    } else {
                        return t\&.color(255, 0, 255) ~ '';
                    }
                }
                when 'comment' { return t\&.color(0, 0, 255) ~ ~$value; }
                default        { return t\&.color(255, 0, 0) ~ '';      }
            } # given $field #
        } elsif $colour {
            given $field {
                when 'key'     { return t\&.color(0, 0, 255) ~ ~$value; }
                when 'host'    { return t\&.color(0, 0, 255) ~ ~$value; }
                when 'port'    { 
                    my Str:D $type = %row«type»;
                    if $type eq 'host' {
                        return t\&.color(0, 0, 255) ~ ~$value;
                    } else {
                        return t\&.color(0, 0, 255) ~ '';
                    }
                }
                when 'comment' { return t\&.color(0, 0, 255) ~ ~$value; }
                default        { return t\&.color(255, 0, 0) ~ '';      }
            }
        } else {
            given $field {
                when 'key'     { return ~$value; }
                when 'host'    { return ~$value; }
                when 'port'    { 
                    my Str:D $type = %row«type»;
                    if $type eq 'host' {
                        return ~$value;
                    } else {
                        return '';
                    }
                }
                when 'comment' { return ~$value; }
                default        { return '';      }
            }
        }
    } #`««« sub field\-value(Int:D $idx, Str:D $field, $value, Bool:D
                            $colour, Bool:D $syntax, Str:D @fields, %row \-\-> Str:D) »»»
    sub between(Int:D $idx, Str:D $field, Bool:D $colour, Bool:D $syntax,
                                                Str:D @fields, %row \-\-> Str:D) {
        if $syntax {
                given $field {
                    when 'key'     {
                        my Str:D $type = %row«type»;
                        if $type eq 'host' {
                            return t\&.color(255, 0, 0) ~ '  => ';
                        } else {
                            return t\&.color(255, 0, 0) ~ ' \-\-> ';
                        }
                    }
                    when 'host'    {
                        my Str:D $type = %row«type»;
                        if $type eq 'host' {
                            return t\&.color(255, 0, 0) ~ ' : ';
                        } else {
                            return t\&.color(255, 0, 0) ~ '   ';
                        }
                    }
                    when 'port'    { return t\&.color(0, 0, 255) ~ ' # '; }
                    when 'comment' { return t\&.color(0, 0, 255) ~ '  ';  }
                    default        { return t\&.color(255, 0, 0) ~ '';    }
                }
        } elsif $colour {
                given $field {
                    when 'key'     {
                        my Str:D $type = %row«type»;
                        if $type eq 'host' {
                            return t\&.color(0, 0, 255) ~ '  => ';
                        } else {
                            return t\&.color(0, 0, 255) ~ ' \-\-> ';
                        }
                    }
                    when 'host'    {
                        my Str:D $type = %row«type»;
                        if $type eq 'host' {
                            return t\&.color(0, 0, 255) ~ ' : ';
                        } else {
                            return t\&.color(0, 0, 255) ~ '   ';
                        }
                    }
                    when 'port'    { return t\&.color(0, 0, 255) ~ ' # '; }
                    when 'comment' { return t\&.color(0, 0, 255) ~ '  ';  }
                    default        { return t\&.color(255, 0, 0) ~ '';    }
                }
        } else {
                given $field {
                    when 'key'     {
                        my Str:D $type = %row«type»;
                        if $type eq 'host' {
                            return '  => ';
                        } else {
                            return ' \-\-> ';
                        }
                    }
                    when 'host'    {
                        my Str:D $type = %row«type»;
                        if $type eq 'host' {
                            return ' : ';
                        } else {
                            return '   ';
                        }
                    }
                    when 'port'    { return ' # '; }
                    when 'comment' { return '  ';  }
                    default        { return '';    }
                }
        }
    } #`««« sub between(Int:D $idx, Str:D $field, Bool:D $colour,
                    Bool:D $syntax, Str:D @fields, %row \-\-> Str:D) »»»
    sub row\-formatting(Int:D $cnt, Bool:D $colour, Bool:D $syntax \-\-> Str:D) {
        if $colour {
            if $syntax { 
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue
                                  if $cnt == \-3; # three heading lines\&. #
                return t\&.bg\-color(0, 0, 127) ~ t\&.bold ~ t\&.bright\-blue
                                                          if $cnt == \-2;
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue
                                                          if $cnt == \-1;
                return (($cnt % 2 == 0) ?? t\&.bg\-yellow !!
                                  t\&.bg\-color(0,255,0)) ~ t\&.bold ~ t\&.bright\-blue;
            } else {
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue
                                                          if $cnt == \-3;
                return t\&.bg\-color(0, 0, 127) ~ t\&.bold ~ t\&.bright\-blue
                                                          if $cnt == \-2;
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue
                                                          if $cnt == \-1;
                return (($cnt % 2 == 0) ?? t\&.bg\-yellow !!
                              t\&.bg\-color(0,255,0)) ~ t\&.bold ~ t\&.bright\-blue;
            }
        } else {
            return '';
        }
    } #`««« sub row\-formatting(Int:D $cnt, Bool:D $colour, Bool:D $syntax \-\-> Str:D) »»»
    return list\-by($prefix, $colour, $syntax, $page\-length, $pattern, $key\-name, @fields,
                            %defaults, %the\-lot, :&include\-row, :&head\-value, :&head\-between,
                            :&field\-value, :&between, :&row\-formatting);
} #`««« sub list\-by\-all(Str:D $prefix, Bool:D $colour is copy, Bool:D $syntax,
                        Int:D $page\-length, Regex:D $pattern \-\-> Bool:D) is export »»»


.EE
.RE
.P
Top of Document [#table-of-contents]
.SS Another example

.RS 4m
.EX
use Terminal::ANSI::OO :t;
use Display::Listings;
use File::Utils;


sub list\-editors\-backups(Str:D $prefix,
                         Bool:D $colour is copy,
                         Bool:D $syntax,
                         Regex:D $pattern,
                         Int:D $page\-length \-\-> Bool:D) is export {
    $colour = True if $syntax;
    my IO::Path @backups = $editor\-config\&.IO\&.dir(:test(rx/ ^ 
                                                           'editors\&.' \d ** 4 '\-' \d ** 2 '\-' \d ** 2
                                                               [ 'T' \d **2 [ [ '\&.' || ':' ] \d ** 2 ] ** {0\&.\&.2} [ [ '\&.' || '·' ] \d+ 
                                                                   [ [ '+' || '\-' ] \d ** 2 [ '\&.' || ':' ] \d ** 2 || 'z' ]?  ]?
                                                               ]?
                                                           $
                                                         /
                                                       )
                                                );
    my $actions = EditorsActions;
    @backups \&.=grep: \-> IO::Path $fl { 
                                my @file = $fl\&.slurp\&.split("\n");
                                Editors\&.parse(@file\&.join("\x0A"), :enc('UTF\-8'), :$actions)\&.made;
                            };
    @backups \&.=sort;
    my @_backups = @backups\&.map: \-> IO::Path $f {
          my %elt = backup => $f\&.basename, perms => symbolic\-perms($f, :$colour, :$syntax),
                      user => $f\&.user, group => $f\&.group, size => $f\&.s, modified => $f\&.modified;
          %elt;
    };
    my Str:D @fields = 'perms', 'size', 'user', 'group', 'modified', 'backup';
    my       %defaults;
    my Str:D %fancynames = perms => 'Permissions', size => 'Size',
                             user => 'User', group => 'Group',
                             modified => 'Date Modified', backup => 'Backup';
    sub include\-row(Str:D $prefix, Regex:D $pattern, Int:D $idx, Str:D @fields, %row \-\-> Bool:D) {
        my Str:D $value = ~(%row«backup» // '');
        return True if $value\&.starts\-with($prefix, :ignorecase) && $value ~~ $pattern;
        return False;
    } # sub include\-row(Str:D $prefix, Regex:D $pattern, Int:D $idx, Str:D @fields, %row \-\-> Bool:D) #
    sub head\-value(Int:D $indx, Str:D $field, Bool:D $colour, Bool:D $syntax, Str:D @fields \-\-> Str:D) {
        #dd $indx, $field, $colour, $syntax, @fields;
        if $colour {
            if $syntax { 
                return t\&.color(0, 255, 255) ~ %fancynames{$field};
            } else {
                return t\&.color(0, 255, 255) ~ %fancynames{$field};
            }
        } else {
            return %fancynames{$field};
        }
    } # sub head\-value(Int:D $indx, Str:D $field, Bool:D $colour, Bool:D $syntax, Str:D @fields \-\-> Str:D) #
    sub head\-between(Int:D $indx, Str:D $field, Bool:D $colour, Bool:D $syntax, Str:D @fields \-\-> Str:D) {
        return ' ';
    } # sub head\-between(Int:D $indx, Str:D $field, Bool:D $colour, Bool:D $syntax, Str:D @fields \-\-> Str:D) #
    sub field\-value(Int:D $idx, Str:D $field, $value, Bool:D $colour, Bool:D $syntax, Str:D @fields, %row \-\-> Str:D) {
        my Str:D $val = ~($value // ''); #`««« assumming $value is a Str:D »»»
        #dd $val, $value, $field;
        if $syntax {
            given $field {
                when 'perms'    { return $val; }
                when 'size'     {
                    my Int:D $size = +$value;
                    return t\&.color(255, 0, 0) ~ format\-bytes($size);
                }
                when 'user'     { return t\&.color(255, 255, 0) ~ uid2username(+$value);    }
                when 'group'    { return t\&.color(255, 255, 0) ~ gid2groupname(+$value);   }
                when 'modified' {
                    my Instant:D $m = +$value;
                    my DateTime:D $dt = $m\&.DateTime\&.local;
                    return t\&.color(0, 0, 235) ~ $dt\&.Str;  
                }
                when 'backup'   { return t\&.color(255, 0, 255) ~ $val; }
                default         { return t\&.color(255, 0, 0) ~ $val;   }
            } # given $field #
        } elsif $colour {
            given $field {
                when 'perms'    { return $val; }
                when 'size'     {
                    my Int:D $size = +$value;
                    return t\&.color(0, 0, 255) ~ format\-bytes($size);
                }
                when 'user'     { return t\&.color(0, 0, 255) ~ uid2username(+$value);    }
                when 'group'    { return t\&.color(0, 0, 255) ~ gid2groupname(+$value);   }
                when 'modified' {
                    my Instant:D $m = +$value;
                    my DateTime:D $dt = $m\&.DateTime\&.local;
                    return t\&.color(0, 0, 255) ~ $dt\&.Str;  
                }
                when 'backup'   { return t\&.color(0, 0, 255) ~ $val;   }
                default         { return t\&.color(255, 0, 0) ~ $val;   }
            } # given $field #
        } else {
            given $field {
                when 'perms'    { return $val; }
                when 'size'     {
                    my Int:D $size = +$value;
                    return format\-bytes($size);
                }
                when 'user'     { return uid2username(+$value);    }
                when 'group'    { return gid2groupname(+$value);   }
                when 'modified' {
                    my Instant:D $m = +$value;
                    my DateTime:D $dt = $m\&.DateTime\&.local;
                    return $dt\&.Str;  
                }
                when 'backup'   { return $val;   }
                default         { return $val;   }
            } # given $field #
        }
    } # sub field\-value(Int:D $idx, Str:D $field, $value, Bool:D $colour, Bool:D $syntax, Str:D @fields, %row \-\-> Str:D) #
    sub between(Int:D $idx, Str:D $field, Bool:D $colour, Bool:D $syntax, Str:D @fields, %row \-\-> Str:D) {
        return ' ';
    } # sub between(Int:D $idx, Str:D $field, Bool:D $colour, Bool:D $syntax, Str:D @fields, %row \-\-> Str:D) #
    sub row\-formatting(Int:D $cnt, Bool:D $colour, Bool:D $syntax \-\-> Str:D) {
        if $colour {
            if $syntax { 
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue if $cnt == \-3; # three heading lines\&. #
                return t\&.bg\-color(0, 0, 127) ~ t\&.bold ~ t\&.bright\-blue if $cnt == \-2;
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue if $cnt == \-1;
                return (($cnt % 2 == 0) ?? t\&.bg\-yellow !! t\&.bg\-color(0,195,0)) ~ t\&.bold ~ t\&.bright\-blue;
            } else {
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue if $cnt == \-3;
                return t\&.bg\-color(0, 0, 127) ~ t\&.bold ~ t\&.bright\-blue if $cnt == \-2;
                return t\&.bg\-color(255, 0, 255) ~ t\&.bold ~ t\&.bright\-blue if $cnt == \-1;
                return (($cnt % 2 == 0) ?? t\&.bg\-yellow !! t\&.bg\-color(0,195,0)) ~ t\&.bold ~ t\&.bright\-blue;
            }
        } else {
            return '';
        }
    } # sub row\-formatting(Int:D $cnt, Bool:D $colour, Bool:D $syntax \-\-> Str:D) #
    return list\-by($prefix, $colour, $syntax, $page\-length,
                  $pattern, @fields, %defaults, @_backups,
                  :!sort,
                  :&include\-row, 
                  :&head\-value, 
                  :&head\-between,
                  :&field\-value, 
                  :&between,
                  :&row\-formatting);
} #`««« sub list\-editors\-backups(Str:D $prefix,
                         Bool:D $colour is copy,
                         Bool:D $syntax,
                         Regex:D $pattern,
                         Int:D $page\-length \-\-> Bool:D) is export »»»


.EE
.RE
.P
Top of Document [#table-of-contents]
.SS An Example of the above code \fBlist\-editors\-backups(…)\fR at work:

! 

.RS 4m
.EX
Permissions Size   User        Group       Date Modified                    Backup                                   
=====================================================================================================================
\&.rw\-rw\-r\-\-  802\&.0B grizzlysmit grizzlysmit 2023\-12\-11T01:23:41\&.634625+11:00 editors\&.2023\-12\-11T01:24:20              
\&.rw\-rw\-r\-\-  802\&.0B grizzlysmit grizzlysmit 2023\-12\-11T21:15:51\&.038790+11:00 editors\&.2023\-12\-11T21:16:28\&.034522+11:00 
\&.rw\-rw\-r\-\-  802\&.0B grizzlysmit grizzlysmit 2023\-12\-11T21:58:20\&.835630+11:00 editors\&.2023\-12\-11T21:58:57\&.832862+11:00 
\&.rw\-rw\-r\-\-  833\&.0B grizzlysmit grizzlysmit 2023\-12\-11T23:21:21\&.450694+11:00 editors\&.2023\-12\-11T23:21:58\&.449520+11:00 
\&.rw\-rw\-r\-\-  820\&.0B grizzlysmit grizzlysmit 2023\-12\-11T23:31:34\&.183842+11:00 editors\&.2023\-12\-11T23:32:11\&.181779+11:00 
\&.rw\-rw\-r\-\-  820\&.0B grizzlysmit grizzlysmit 2023\-12\-12T21:59:45\&.479111+11:00 editors\&.2023\-12\-12T22:00:22\&.468348+11:00 
=====================================================================================================================


.EE
.RE
.P
|/docs/images/sc\-list\-editors\-backups\&.png>

Top of Document [#table-of-contents]
